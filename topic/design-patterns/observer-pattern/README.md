### 观察者模式

1. 一个对象维护一些列依赖于他的对象， 将有关状态的任何变更自动通知给他们， 我最先想到的是 **Object.defineProperty**和 **Proxy**, 监听某一个对象，这个对象的某个属性发生改变时，通知其他监听他的对象，但是好像这个是发布订阅模式。。。
2. 当一个目标需要告诉观察者发生了什么事情的时候， 会向所有的观察者广播一个通知，包括与通知主题相关的特定数据
3. 当我们不在希望某个特定的观察者获得其注册目标发出的改变通知的时候，可以从观察者列表中删除
4. 所以我们需要以下几个组件，分别是
   1. 目标 _维护一系列的观察者，方便添加或删除观察者_
   2. 观察者 _为那些在目标状态发生改变的时候需要获得通知的对象提供一个更新接口_
   3. 具体目标 _状态发生改变时，向观察者发出通知，储存具体观察者的状态_
   4. 具体观察者 _存储一个执行具体目标的索引，保证自身状态和目标状态保持一致_

### 个人总结

1. 利用工厂，原型，构造器，混合 等任何一种方式， 构造出一个对象。 对象具有一系列的方法。 每个对象都有一个值， 是与目标有关的， 当目标发生改变， 该值会跟着变化
2. 利用工厂，原型，构造器，混合 等任何一种方式， 构造出一个对象。这就是目标对象。 目标里可以维护一个数组，数据每一个成员都是观察者。 当目标对象发生改变的时候，遍历数组，让数组每一个成员都相应的改变

### demo

1. 用于向页面添加新的 checkbox 按钮
2. 控制 checkbox，当做一个目标对象，通知其他的 checkbox 进行检查。

### 优点

1. 鼓励我们思考应用程序之间不同步那份之间的关系，帮助我们识别包含直接关系的层，并且可以用目标集和观察者进行替换，可以用于将应用程序分解为更小，更松散耦合的快， 以此来改进代码管理和钱在的复用。

### 缺点

1. 发布者可能会假设， 一个或者多个订阅者在监听他们， 如果我们假设订阅者需要记录或者输出一些与应用处理有关的错误， 如果订阅者的执行日记崩溃了， 由于系统的解耦特性， 发布者就不会看到这一点
2. 订阅者非常务实彼此的存在， 并且对变化发布者产生的成本十二不建，很难跟踪依赖更新。
